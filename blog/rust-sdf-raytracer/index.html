<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width" name=viewport><meta content="I built my own business card raytracer in Rust, because why not" property=og:title><meta content=website property=og:type><meta content="Andrea Venuta" property=og:site_name><meta content="As you may know, and if you&amp#x27;re reading this chances are you do, there&amp#x27;s
this post that&amp#x27;s
been roaming around for 7 years and periodically resurfaces. It refers to a
code golfing challenge dating back in 1984, a few years before I was born.
Its rules asked to build a raytracer in C with certain features and
functions and shading models. Among those, Andrew Kensler&amp#x27;s version, checking
in at 1337 bytes, stood out and became world-wide renowned (for good reasons,
if you ask me). This was its output." property=og:description><title>I built my own business card raytracer in Rust, because why not</title><link href=https://veeenu.github.io/style.css rel=stylesheet><link href=https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet><link integrity="sha512-vJqxkZ+Sugf/6WRlpcxN01qVfX/29hF6qc33eHF1va3NgoV+U+wCi+uTAsQ10sDoGyBxHLdaHvGwDlV3yVYboA==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css referrerpolicy=no-referrer rel=stylesheet><script integrity="sha512-5ufNcHqOYgilGEHPfuRIQ5B/vDS1M8+UC+DESZ5CwVgGTg+b2Ol/15rYL/GiCWJ/Sx8oVo0FPFok1dPk8U9INQ==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js></script><script integrity="sha512-MBhOGY4yRA2eATtRGTcrDJCRqcnLai5+uu47GA2ueVr1MPzirC/iogLWRA8CXTlOTK09VI4fdTe4qE4LBfjsHw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mathtex-script-type.min.js></script><script integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js></script><script>document.addEventListener(`DOMContentLoaded`,(()=>{let a=`\$\$`,b=`\$`;renderMathInElement(document.body,{delimiters:[{left:a,right:a,display:!0},{left:b,right:b,display:!1},{left:`\\\\(`,right:`\\\\)`,display:!1},{left:`\\\\[`,right:`\\\\]`,display:!0}],throwOnError:!1})}))</script><body><header id=menu-header><a class=image href=https://veeenu.github.io> <div><img alt="Andrea Venuta" src=https://veeenu.github.io/me.jpg></div> <span>Andrea Venuta</span> </a><ul><li><a href=https://veeenu.github.io>About</a><li><a href=https://veeenu.github.io/blog.html>Blog</a></ul></header><div class="container top-container"><article class="article twelve columns"><header><h1>I built my own business card raytracer in Rust, because why not</h1><small> <p><time>Wednesday, 29 Apr 2020</time> Â· <em> Reading time: 9 mins </em></p> </small></header><section><p>As you may know, and if you're reading this chances are you do, there's <a href=https://fabiensanglard.net/rayTracing_back_of_business_card/>this post</a> that's been roaming around for 7 years and periodically resurfaces. It refers to a code golfing challenge dating back in 1984, a few years before I was born. Its rules asked to build a raytracer in C with certain features and functions and shading models. Among those, Andrew Kensler's version, checking in at 1337 bytes, stood out and became world-wide renowned (for good reasons, if you ask me). This was its output.</p><span id=continue-reading></span><p><img alt="Andrew Kensler's business card raytracer" src=https://fabiensanglard.net/rayTracing_back_of_business_card/minray.png><p>So, last time I found it on the Hackernews frontpage, I just left it open in a tab for weeks on end. You know, just in case, like one always does. That is, until one fine night the pointless side project fairy visited me in my sleep and whispered in my ear.<p>The following morning I opened my eyes and knew what I had to do.<p>I have been wanting to get back into graphics programming for quite a while now, but job duties and personal commitments kept me away from it; besides, as I'm in the process of switching careers, it is high time I polished my professional appearance and got myself a proper business card (by the way, at the time of writing this, <a href=/cv.pdf>I'm still open to offers</a>, nudge nudge, wink wink).<h2 id=and-here-it-is>And here it is</h2><p><img alt="The raytracer's rendering" src=/data/2020-04-29/render.png><pre style=color:#6c7079;background-color:#2b303b><code><span style=color:#abb2bf>use std::ops::*;type F=f64;#[derive(Clone,Copy)]struct V(F,F
</span><span style=color:#abb2bf>,F);#[derive(Clone,Copy)]struct M(F,F,F,F,F,F,F,F,F,F,F,F,F,
</span><span style=color:#abb2bf>F,F,F);fn a(v:V)->V{V(v.0 .abs(),v.1.abs(),v.2.abs())}fn z(l
</span><span style=color:#abb2bf>:V,r:V)->F{(l.0*r.0+l.1*r.1+l.2*r.2).sqrt()}fn T(v:V,f:F)->V
</span><span style=color:#abb2bf>{V(v.0*f,v.1*f,v.2*f)}impl Add&LTV>for V{type Output=V;fn add(
</span><span style=color:#abb2bf>self,r:V)->V{V(self.0+r.0, self.1+r.1,self.2+r.2)}}impl Neg
</span><span style=color:#abb2bf>for V{type Output=V;fn neg(self)->V{V(-self.0,-self.1,-self.
</span><span style=color:#abb2bf>2)}}impl Mul&LTV>for M{type Output=V;fn mul(self,r:V)->V{let(V
</span><span style=color:#abb2bf>(x,y,z),M(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p))=(r,self);let w=d
</span><span style=color:#abb2bf>*x+h*y+l*z+p;T(V(a*x+e*y+i*z+m,b*x+f*y+j*z+n,c*x+g*y+k*z+o),
</span><span style=color:#abb2bf>1./w)}}fn m(l:V,r:V)->V{V(F::max(l.0,r.0),F::max(l.1,r.1),F
</span><span style=color:#abb2bf>::max(l.2,r.2))}fn b(r:V,p: V,s:V)->F{let d=a(r+-p)+-s;let n
</span><span style=color:#abb2bf>=F::max(d.0,F::max(d.1,d.2));F::min(n,0.)+(|v|z(v,v))(m(d,V(
</span><span style=color:#abb2bf>0.,0.,0.)))}fn c(r:V,h:F,d:F)->F{let p=a(r);let(x,y)=((p.0*p
</span><span style=color:#abb2bf>.0+p.2*p.2).sqrt().abs()-h,p.1-d);let(z,w)=(F::max(x,0.),F::
</span><span style=color:#abb2bf>max(y,0.));F::min(F::max(x,y),0.)+(z*z+w*w).sqrt()}fn d(r:V)
</span><span style=color:#abb2bf>->(F,u64){let z=0.5;let(y,w)=(0.707,0.866);let(a,d,e,f,g,h,i
</span><span style=color:#abb2bf>,j,k,l)=(M(0.5,-w,0.,0.,w,0.5,0.,0.,0.,0.,1.,0.,-1.,0.,0.,1.
</span><span style=color:#abb2bf>),M(-0.5,-w,0.,0.,w,-0.5,0.,0.,0.,0.,1.,0.,-1.,0.,0.,1.),M(
</span><span style=color:#abb2bf>1.,0.,0.,0.,0.,0.,-1.,0.,0.,1.,0.,-0.,0.,0.,0.,1.),M(1.,0.,
</span><span style=color:#abb2bf>0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,1.5,0.5,0.,1.),M(1.,0.,0.,0.,
</span><span style=color:#abb2bf>0.,0.,-1.,0.,0.,1.,0.,-0.,0.,0.,0.,1.),M(y,-0.,y,0.,0.,1.,0.
</span><span style=color:#abb2bf>,0.,-y,0.,y,0.,-0.212,0.,-0.5,1.),M(1.,0.,0.,0.,0.,1.,0.,0.,
</span><span style=color:#abb2bf>0.,0.,1.,0.,0.,0.,0.,1.),M(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,
</span><span style=color:#abb2bf>0.,-1.5,0.,0.,1.),M(1.,0.,0.,0.,0.,-1.,-0.,0.,0.,0.,-1.,0.,-
</span><span style=color:#abb2bf>0.,0.,0.,1.),M(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,-3.,0.,0.
</span><span style=color:#abb2bf>,1.));let(u,s,o)=(|a,b|F::min(a,b),|a:F,b|F::max(-a,b),i*(g*
</span><span style=color:#abb2bf>r));let(n,p,q,r)=(f*r,h*o,j*o,l*(k*o));[(u(u(b(a*n,V(0.,0.,
</span><span style=color:#abb2bf>0.),V(1.,0.1,z)),b(d*n,V(0.,0.,0.),V(1.,0.1,z))),c(e*n,0.1,z
</span><span style=color:#abb2bf>)),1),(u(s(s(b (o,V(0.5,0.,-0.1),V(0.5,z*2.,0.2)),b(p,V(0.,
</span><span style=color:#abb2bf>0.,0.),V(0.2,z*2.,0.2))),s(c(o,0.4,z*2.),c(o,0.6,z))),b(o,V(
</span><span style=color:#abb2bf>0.,0.,0.),V(0.5,z,0.1))),2),(u(b(q,V(0.5,0.,0.3),V(0.1,z,0.3
</span><span style=color:#abb2bf>)),u(b(q,V(-0.5,0.,0.),V(0.1,z,0.6)),s(b(q,V(0.,0.,0.6),V(
</span><span style=color:#abb2bf>0.6,z*2.,0.6)),s(c(q,0.4,z*2.),c(q,0.6,z))))),3),(u(b(r,V(-
</span><span style=color:#abb2bf>0.5,0.,0.3),V(0.1,z,0.3)),u(b(r,V(0.5,0.,0.),V(0.1,z,0.6)),s
</span><span style=color:#abb2bf>(b(r,V(0.,0.,0.6),V(0.6,z*2.,0.6)),s(c(r,0.4,z*2.),c(r,0.6,z
</span><span style=color:#abb2bf>))))),4)].iter().fold((6.,0),|t,o|if t.0<=o.0{t}else{*o})}fn
</span><span style=color:#abb2bf>i(e:V,i:V)->(F,u64){let(mut f,mut g,mut t)=(0.002,0.,(-1.,0)
</span><span style=color:#abb2bf>);for _ in 0..100{if f&LT0.001||g>30.{break}t=d(e+T(i,g));f=t.
</span><span style=color:#abb2bf>0;g+=t.0;}if g&LT30.{(g,t.1)}else{(30.,0)}}fn r(x:u64,y:u64)->
</span><span style=color:#abb2bf>V{let(p,o,t,n)=(((-1280.+x as F*2.)/720.,(-720.+y as F*2.)/
</span><span style=color:#abb2bf>720.),V(3.,2.,4.),V(1.25,0.,0.),|v:V|T(v,1./z(v,v)));let e={
</span><span style=color:#abb2bf>let(x,w)=(|l:V,r:V|V(l.1*r.2-l.2*r.1,l.2*r.0-l.0*r.2,l.0*r.1
</span><span style=color:#abb2bf>-l.1*r.0),n(t+-o));let u=n(x(w,V(0.,1.,0.)));let v=n(x(u,w))
</span><span style=color:#abb2bf>;M(u.0,v.0,w.0,0.,u.1,v.1,w.1,0.,u.2,v.2,w.2,0.,0.,0.,0.,1.)
</span><span style=color:#abb2bf>};let q=n(e*V(p.0,p.1,2.));let t=i(o,q);let h=o+T(q,t.0);let
</span><span style=color:#abb2bf>m={let(x,y,z,e)=(V(0.001,0.,0.),V(0.,0.001,0.),V(0.,0.,0.001
</span><span style=color:#abb2bf>),d(h).0);n(V(d(h+x).0-e,d(h+y).0-e,d(h+z).0-e))};let l=F::
</span><span style=color:#abb2bf>max(0.1,(|h:V,m|F::max(0.,z(n(V(4.,2.,2.)+-h),m)))(h,m));T(
</span><span style=color:#abb2bf>match t.1{1=>V(0.024,0.32,0.26),2=>V(0.33,0.44,0.27),3=>V(
</span><span style=color:#abb2bf>0.4,0.61,0.37),4=>V(0.58,0.75,0.46),_=>V(0.,0.,0.),},l*255.)
</span><span style=color:#abb2bf>}fn main(){print!("P3 1280 720 255 ");for y in(1..=720).rev(
</span><span style=color:#abb2bf>){for x in 0..1280{let V(a,b,c)=r(x,y);print!(
</span><span style=color:#abb2bf>"{:.0} {:.0} {:.0} ",a,b,c);}}} // bc > venu.ppm
</span></code></pre><p>Granted, it's not as visually fancy as Kensler's version, nor particularly good looking. But it gets the job done, and it has allowed me to experiment on a number of techniques. At 3306 characters, it's also considerably beefier. You can find the full code of my version, but in a much more tolerable shape, <a href=/data/2020-04-29/main_full.rs>here</a>.<p>The general idea was sourced from <a href=https://www.shadertoy.com/view/Xl2XWt>this nice ShaderToy</a> which has everything thoroughy explained. I had to of course give the concepts a nice twist. For starters, that's GLSL code: it has, among the others, all the primitives for manipulating vectors and matrices -- a luxury that plain Rust does not offer me. Using external crates sounded a bit like cheating, so I chose not to do that.<h3 id=vec3>Vec3</h3><p>First thing I did, then, was to reimplement whatever I needed of said algebra functions. This amounts to operations on 3-vectors and 4-matrices used for transformations.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>type </span><span style=color:#abb2bf>f </span><span style=color:#adb7c9>= </span><span style=color:#cd74e8>f64</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>#[</span><span style=color:#eb6772>derive</span><span style=color:#abb2bf>(Clone, Copy, Debug)]
</span><span style=color:#cd74e8>struct </span><span style=color:#abb2bf>Vec3(f, f, f);
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>impl </span><span style=color:#abb2bf>Vec3 {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>length</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>) -> f {
</span><span style=color:#abb2bf>    (</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>* </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>* </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>* </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>abs</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>) -> Vec3 {
</span><span style=color:#abb2bf>    Vec3(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0.</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>(), </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1.</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>(), </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2.</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>())
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>normal</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>) -> Vec3 {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> l </span><span style=color:#adb7c9>= </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#5ebfcc>length</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>    Vec3(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>/</span><span style=color:#abb2bf> l, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>/</span><span style=color:#abb2bf> l, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>/</span><span style=color:#abb2bf> l)
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>cross</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>rhs</span><span style=color:#abb2bf>: Vec3) -> Vec3 {
</span><span style=color:#abb2bf>    Vec3(
</span><span style=color:#abb2bf>      </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>- </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>      </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>- </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>      </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>- </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>0
</span><span style=color:#abb2bf>    )
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>dot</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>rhs</span><span style=color:#abb2bf>: Vec3) -> f {
</span><span style=color:#abb2bf>    (</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>}
</span></code></pre><p>This is a bit verbose, but these operations appear in a lot of places, so gathering them somewhere is bound to save me some space later on. Operations like the dot product could be put in an <code>impl</code> block, where you have to wrangle with the <code>self</code> argument -- yikes! 4 unavoidable characters every single time! A better option, if less idiomatic, is to simply write a regular <code>fn</code> with one-character argument names (nice and comprehensible!). This saves a lot of bytes:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#5f697a;font-style:italic>// impl version, more chars
</span><span style=color:#cd74e8>impl </span><span style=color:#abb2bf>Vec3 {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>dot</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>r</span><span style=color:#abb2bf>: Vec3) -> f {
</span><span style=color:#abb2bf>    (</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>+ </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>v.</span><span style=color:#5ebfcc>dot</span><span style=color:#abb2bf>(r)
</span><span style=color:#abb2bf>
</span><span style=color:#5f697a;font-style:italic>// fn version, less chars
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>dot</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>l</span><span style=color:#abb2bf>: Vec3, </span><span style=color:#eb6772>r</span><span style=color:#abb2bf>: Vec3) -> f {
</span><span style=color:#abb2bf>  (l.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> l.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> l.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#5ebfcc>dot</span><span style=color:#abb2bf>(v,r) </span><span style=color:#5f697a;font-style:italic>// same number of chars
</span></code></pre><p>Another important thing was deciding what to do with the basic operations. Those are used a huge number of times in the code, but the trait syntax is very verbose; is all of this typing worth it?<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>impl </span><span style=color:#abb2bf>Add&LTVec3> </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>Vec3 {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>type </span><span style=color:#abb2bf>Output </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> Vec3;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>add</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>rhs</span><span style=color:#abb2bf>: Vec3) -> Vec3 {
</span><span style=color:#abb2bf>    Vec3(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>impl </span><span style=color:#abb2bf>Sub&LTVec3> </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>Vec3 {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>type </span><span style=color:#abb2bf>Output </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> Vec3;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>sub</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>rhs</span><span style=color:#abb2bf>: Vec3) -> Vec3 {
</span><span style=color:#abb2bf>    Vec3(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> rhs.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>)
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>impl </span><span style=color:#abb2bf>Mul&LTf> </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>Vec3 {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>type </span><span style=color:#abb2bf>Output </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> Vec3;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>mul</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>rhs</span><span style=color:#abb2bf>: f) -> Vec3 {
</span><span style=color:#abb2bf>    Vec3(</span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs, </span><span style=color:#eb6772>self</span><span style=color:#abb2bf>.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> rhs)
</span><span style=color:#abb2bf>  }
</span><span style=color:#abb2bf>}
</span></code></pre><p>Turns out, it is:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#5f697a;font-style:italic>// std::ops traits
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> v </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> a</span><span style=color:#adb7c9>+</span><span style=color:#abb2bf>b</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>c;
</span><span style=color:#5f697a;font-style:italic>// one-word functions
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> v </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>s</span><span style=color:#abb2bf>(</span><span style=color:#5ebfcc>m</span><span style=color:#abb2bf>(b,c),a);
</span></code></pre><p>That's around double the characters, and for two simple operations! So paying the cost of implementing operation traits is definitely worth it when they are going to be used that many times.<p>A small note on this: I ended up saving a bunch of characters by not implementing <code>Sub&LTVec3> for Vec3</code>, and going for <code>Neg for Vec3</code> instead. This saved me from having to type all the arguments out of <code>rhs</code>, at the cost of specifying subtractions as <code>a + -b</code> instead of simply <code>a - b</code>. Again, the cost of an extra + in some places was worth it in the end, as I had relatively fewer subtractions than additions. I wonder: could it be a good idea for the <code>ops</code> trait to have <code>Sub&LTB: Neg> for A: Add</code> auto-implemented as <code>self + (-rhs)</code>?<h3 id=mat4>Mat4</h3><pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#abb2bf>#[</span><span style=color:#eb6772>derive</span><span style=color:#abb2bf>(Clone, Copy, Debug)]
</span><span style=color:#cd74e8>struct </span><span style=color:#abb2bf>Mat4(
</span><span style=color:#abb2bf>  f, f, f, f,
</span><span style=color:#abb2bf>  f, f, f, f,
</span><span style=color:#abb2bf>  f, f, f, f,
</span><span style=color:#abb2bf>  f, f, f, f,
</span><span style=color:#abb2bf>);
</span></code></pre><p>At first, I implemented a full-fledged linear transform set of operations on <code>Mat4</code>, so that I could build the transformations on the fly. Then I realized I did not really need to do that -- a <script type=math/tex>R_{4\times4} \times R_4 \to R_4</script> (note: vectors are actually in <script type=math/tex>R_3</script> but augmented with a 1; it <a href=https://en.wikipedia.org/wiki/Affine_transformation#Augmented_matrix>works like that</a>) multiplication function, aptly named something clear and immediate to understand like <code>Z</code> or <code>q</code> or <code>m</code>, would have been more than enough to do whatever I needed to do after actually hardcoding the necessary transformation matrices.<h3 id=distance-functions>Distance functions</h3><p>The overall idea of raytracing distance fields is to define some function that can tell me how distant I am from the outer boundary of some object. For example, if I have a sphere of radius 5 located at <code>(0, 0, 10)</code> and cast a ray starting from the origin, the distance will be:<ul><li>positive along the ray that goes from <code>(0, 0, 0)</code> to <code>(0, 0, 5)</code>;<li>exactly zero in <code>(0, 0, 5)</code>;<li>negative from there to <code>(0, 0, 15)</code>;<li>zero there;<li>and then again positive onwards.</ul><p>Thus, negative or zero values for a given point means I have hit something. Turns out, a lot of these functions can be represented with closed form vector algebra (check <a href=https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm>Inigo Quilez's comprehensive list</a>).<p>From there, for every ray cast, I can pick the closest SDF solid by marching along the ray and stopping as soon as one of the SDFs returns zero or negative distance. Furthermore, I can pair an identifier that represents the object to each SDF function call. This way I can apply different shading rules (a blue sphere, a red box).<p>A super interesting thing: we aren't limited to primitive shapes, but we can play a lot with Boolean algebra by doing intersections, subtractions and unions, and even more complex stuff. But I was content with the basics, and ended up only needing a box function, a cylinder function and the base Boolean algebra:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>op_union</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>: f, </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>: f) -> f {
</span><span style=color:#abb2bf>  f::min(a, b)
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>op_subtraction</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>src</span><span style=color:#abb2bf>: f, </span><span style=color:#eb6772>dest</span><span style=color:#abb2bf>: f) -> f {
</span><span style=color:#abb2bf>  f::max(</span><span style=color:#adb7c9>-</span><span style=color:#abb2bf>src, dest)
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>op_intersection</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>src</span><span style=color:#abb2bf>: f, </span><span style=color:#eb6772>dest</span><span style=color:#abb2bf>: f) -> f {
</span><span style=color:#abb2bf>  f::max(src, dest)
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>sdf_box</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>ray</span><span style=color:#abb2bf>: Vec3, </span><span style=color:#eb6772>pos</span><span style=color:#abb2bf>: Vec3, </span><span style=color:#eb6772>size</span><span style=color:#abb2bf>: Vec3) -> f {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> adj </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> ray </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> pos;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dist_vec </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> adj.</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>() </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> size;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> max_dist </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>f::max(dist_vec.</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>, f::max(dist_vec.</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>, dist_vec.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>));
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> box_dist </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>f::min(max_dist, </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>+ </span><span style=color:#5ebfcc>max</span><span style=color:#abb2bf>(dist_vec, Vec3(</span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>)).</span><span style=color:#5ebfcc>length</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>  box_dist
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>sdf_cyl</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>ray</span><span style=color:#abb2bf>: Vec3, </span><span style=color:#eb6772>h</span><span style=color:#abb2bf>: f, </span><span style=color:#eb6772>r</span><span style=color:#abb2bf>: f) -> f {
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> p </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> ray.</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(p.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> p.</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> p.</span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> p.</span><span style=color:#db9d63>2</span><span style=color:#abb2bf>).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>abs</span><span style=color:#abb2bf>() </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> h;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> p.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> r;
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>(cx, cy) </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(f::max(x, </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>), f::max(y, </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>));
</span><span style=color:#abb2bf>  f::min(f::max(x, y), </span><span style=color:#db9d63>0.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>+ </span><span style=color:#abb2bf>(cx </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> cx </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> cy </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> cy).</span><span style=color:#5ebfcc>sqrt</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>}
</span></code></pre><p>I made the <code>V</code> by intersecting one box rotated counterclockwise, one box rotated clockwise, and one cylinder at the intersection of the two, to make a rounded bottom. The <code>E</code> was reasonably more complex, so I'll let a picture speak in my stead, as drawing that is what I actually needed to do to figure it out in the first place:<p><img alt=E src=/data/2020-04-29/e.jpg><p>A tall box on the left, a shorter box on the right, and an arc made by subtracting a small cylinder from a larger one, and there you have it: the <code>N</code>, much simpler (I think you can imagine the shapes by now if you scroll up to the rendering). The <code>U</code> was made in the same way but upside down. I've seen better thought-out font designs out there, I must admit, but hey, we all have to start somewhere.<h3 id=a-few-more-optimizations>A few more optimizations</h3><p>Past a couple <code>let</code> statements, it is more convenient to exploit tuple expansion to save space:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> a </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2.</span><span style=color:#abb2bf>;
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> b </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>3.</span><span style=color:#abb2bf>;
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> c </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>4.</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>
</span><span style=color:#5f697a;font-style:italic>// becomes
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf>(a,b,c) </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(</span><span style=color:#db9d63>2.</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>3.</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>4.</span><span style=color:#abb2bf>);
</span></code></pre><p>Clearly this is not applicable in places where I need the output of a previous computation, as the result of an expression is not immediately visible in the same expression:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf>(a,b,c) </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(</span><span style=color:#db9d63>2.</span><span style=color:#abb2bf>, a </span><span style=color:#adb7c9>+ </span><span style=color:#db9d63>1.</span><span style=color:#abb2bf>, b </span><span style=color:#adb7c9>+ </span><span style=color:#db9d63>1.</span><span style=color:#abb2bf>); </span><span style=color:#5f697a;font-style:italic>// NOPE!
</span></code></pre><p>Expanding the tuple also allows to exploit the whitespace next to <code>let</code>. It's not much, but one byte here, one byte there, I overall ended up saving upwards of 2000 characters.<p>If I had a function used only inside of some other function, but which was too bytes-expensive to inline, I replaced its module-level definition with a closure. For example, I only had to do Boolean algebra in one place, so:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#5f697a;font-style:italic>// op_subtraction
</span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>s</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>s</span><span style=color:#abb2bf>: f, </span><span style=color:#eb6772>d</span><span style=color:#abb2bf>: f) -> f {
</span><span style=color:#abb2bf>  f::max(</span><span style=color:#adb7c9>-</span><span style=color:#abb2bf>s, d)
</span><span style=color:#abb2bf>}
</span><span style=color:#5f697a;font-style:italic>// becomes
</span><span style=color:#adb7c9>|</span><span style=color:#abb2bf>s,d</span><span style=color:#adb7c9>|</span><span style=color:#abb2bf>f::max(</span><span style=color:#adb7c9>-</span><span style=color:#abb2bf>s,d)
</span></code></pre><h3 id=conclusions>Conclusions</h3><p>And now for something completely different -- I want to talk about what doing this kind of things feels like. It bears repeating <a href=/2014/04/07/js1k-2014-post-mortem.html>what I said a while ago</a>: writing the super-clean, well indented, well commented, well-architected full stack application with bells, whistles, ironed shirt and firm handshake is a completely different experience from doing this kind of thing. It feels much more like exploratory data analysis, as it is much harder to fully grasp the hierarchy of the code when you're purposefully trying to sacrifice all the best practices you've learned in your career upon the altar of small code. Much more so when you're dabbling in math-heavy techniques such as raytracing, which would benefit greatly from structure and abstractions. I believe my code could be much, much terser than that. But with none of the usual intellectual crutches I rely upon, with the passing of time it felt like any change had harder and harder consequences to predict, and it was harder and harder to evaluate whether I was saving or wasting characters.<p>At the end of the day, the frustration of not being able to figure stuff out is paid off many times over by the jolt of satisfaction you get when you finally do, and all of that has a constant backdrop of adrenaline from attempting any of the billion ideas you come up with (and can't look up on StackOverflow) to try to solve stuff.<p>Anyway, I'm dr. Venuta, glad to meet you!<p><img alt="Business card" src=/data/2020-04-29/bcard.png><p>I spent way more time than I think is reasonable on this small piece of code; but then again, I spend way more time than I think is reasonable on videogames as well. And I regret neither:<blockquote><p>Time you enjoy wasting is not wasted time<br> And with strange aeons even time can waste time<br> -- <em>Abdul Alhazprocrastinated</em>, iirc.</blockquote></section></article><ul class=links><li><a href=https://github.com/veeenu target=_blank> <img alt=GitHub src=/img/github.svg> </a><li><a href=https://www.linkedin.com/in/andreavenuta/ target=_blank> <img alt=LinkedIn src=/img/linkedin.svg> </a><li><a href=https://twitter.com/johndisandonato target=_blank> <img alt=Twitter src=/img/twitter.svg> </a><li><a href=https://twitch.tv/johndisandonato target=_blank> <img alt=Twitch.tv src=/img/twitch.svg> </a><li><a href=cv.pdf target=_blank> <img alt="CV - Icon made by Vitaly Gorbachev (https://www.flaticon.com/authors/vitaly-gorbachev) from www.flaticon.com" src=/img/cv.svg> </a></ul></div><script async src=/katex.min.js></script><script data-cf-beacon='{"token": "9c82a3cc7db742e4bb18aebd57b40893"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script>