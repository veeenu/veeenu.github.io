<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width" name=viewport><meta content="Learning Haskell with Venu: Cellular automata" property=og:title><meta content=website property=og:type><meta content="Andrea Venuta" property=og:site_name><meta content="Lately I&amp#x27;ve been experimenting a lot with a number of CG and procedural content
generation algorithms, and began feeling the need for mathematical rigour over
the practical, &ampquot;real life situation&ampquot; style I&amp#x27;ve been used to by writing
Javascript day in, day out. I got to a point where simple simulations required
way more boilerplate code than I was willing to write, and the usage of native
numeric constructs began getting in the way of performance." property=og:description><title>Learning Haskell with Venu: Cellular automata</title><link href=https://veeenu.github.io/style.css rel=stylesheet><link href=https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet><link integrity="sha512-vJqxkZ+Sugf/6WRlpcxN01qVfX/29hF6qc33eHF1va3NgoV+U+wCi+uTAsQ10sDoGyBxHLdaHvGwDlV3yVYboA==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css referrerpolicy=no-referrer rel=stylesheet><script integrity="sha512-5ufNcHqOYgilGEHPfuRIQ5B/vDS1M8+UC+DESZ5CwVgGTg+b2Ol/15rYL/GiCWJ/Sx8oVo0FPFok1dPk8U9INQ==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js></script><script integrity="sha512-MBhOGY4yRA2eATtRGTcrDJCRqcnLai5+uu47GA2ueVr1MPzirC/iogLWRA8CXTlOTK09VI4fdTe4qE4LBfjsHw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mathtex-script-type.min.js></script><script integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js></script><script>document.addEventListener(`DOMContentLoaded`,(()=>{let a=`\$\$`,b=`\$`;renderMathInElement(document.body,{delimiters:[{left:a,right:a,display:!0},{left:b,right:b,display:!1},{left:`\\\\(`,right:`\\\\)`,display:!1},{left:`\\\\[`,right:`\\\\]`,display:!0}],throwOnError:!1})}))</script><body><header id=menu-header><a class=image href=https://veeenu.github.io> <div><img alt="Andrea Venuta" src=https://veeenu.github.io/me.jpg></div> <span>Andrea Venuta</span> </a><ul><li><a href=https://veeenu.github.io>About</a><li><a href=https://veeenu.github.io/blog.html>Blog</a></ul></header><div class="container top-container"><article class="article twelve columns"><header><h1>Learning Haskell with Venu: Cellular automata</h1><small> <p><time>Monday, 20 Oct 2014</time> Â· <em> Reading time: 4 mins </em></p> </small></header><section><p>Lately I've been experimenting a lot with a number of CG and procedural content generation algorithms, and began feeling the need for mathematical rigour over the practical, "real life situation" style I've been used to by writing Javascript day in, day out. I got to a point where simple simulations required way more boilerplate code than I was willing to write, and the usage of native numeric constructs began getting in the way of performance.</p><span id=continue-reading></span><p>For example, I was working on an <script type=math/tex>O(n)</script> image processing algorithm, representing the pixels as plain 1D arrays, and I discovered that wrapping the aforementioned array inside a native <code>Uint32Array</code> produced an impressive performance boost, cutting the execution time from ~46ms to ~1.5ms at the expense of adding a little boilerplate code. Which is great in and of itself, but not so great in terms of code cleanliness, and code cleanliness is fundamental when I'm trying to represent somewhat complex mathematical ideas.<p>So I decided to look into functional programming. After reading about it for a bit, I began working my way through the <a href=https://github.com/veeenu/ninetynine-haskell-problems>Ninety-nine Haskell Problems</a> to get comfortable with the new paradigm, and then decided to prototype something a bit more challenging.<h3 id=cellular-automata>Cellular automata</h3><p>I chose to implement a simple cellular automaton. A <em>cellular automaton</em> is a discrete computation model defined over a grid of cells, each one having a state. Each step of the computation, called <em>generation</em>, involves computing a new state for each cell that depends upon the previous states of the cell and of a chosen subset of neighboring cells. The criteria with which the new state is computed are called <em>rules</em> and are, basically, a function of those previous states.<p>Let's choose a neighborhood in the form of the <a href=http://en.wikipedia.org/wiki/Moore_neighborhood>Moore neighborhood</a>. Let <script type=math/tex>A</script> denote the 2D matrix representing the automaton. The Moore neighborhood for a generic cell <script type=math/tex>A_{x,y}</script> is defined as</p><script type=math/tex>N_{x,y}(A) = \left\{ A_{x+i,y+j} \mid (i, j) \in [-1 .. 1]^2 \setminus (0, 0) \right\}</script><p>Let <script type=math/tex>A^i</script> be the matrix at the <script type=math/tex>i</script> th generation. We could say that</p><script type=math/tex>A^i_{x,y} = f(A^{i-1}_{x,y},N_{x,y}(A^{i-1}))</script><p>Finally, we could decide our rule function <script type=math/tex>f</script> to be a simplified version of the one described in this <a href=http://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664>nice article</a> about cellular automata which I suggest you read, too.</p><script type=math/tex>f(a_0,a_1...a_n) = \begin{cases} 1 &\mbox{} \sum\limits_{i=1}^n a_i > 4 \\
                   0 &\mbox{} otherwise \end{cases}</script><p>I decided to represent the automaton's grid as a plain 1D array. The <code>generation</code> function is defined inductively with great ease; being <code>vec</code> the array containing the grid, the generation 0 is the array itself, and each subsequent generation is defined as the <code>step</code> function mapped over the values of the previous generation. <code>step</code> corresponds to the <script type=math/tex>f</script> defined before, and the sum over the neighborhood is represented as the fold of the sum operation over the cell values extracted by the <code>getCell</code> function.<pre class=language-haskell data-lang=haskell style=color:#6c7079;background-color:#2b303b><code class=language-haskell data-lang=haskell><span style=color:#5cb3fa>generation </span><span style=color:#cd74e8>:: Int -></span><span style=color:#abb2bf> [</span><span style=color:#cd74e8>Int</span><span style=color:#abb2bf>] </span><span style=color:#cd74e8>-></span><span style=color:#abb2bf> [</span><span style=color:#cd74e8>Int</span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>generation </span><span style=color:#db9d63>0</span><span style=color:#abb2bf> vec </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> vec
</span><span style=color:#abb2bf>generation i vec </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> map step [</span><span style=color:#db9d63>0 </span><span style=color:#adb7c9>..</span><span style=color:#abb2bf> length vec]
</span><span style=color:#abb2bf>  </span><span style=color:#cd74e8>where
</span><span style=color:#abb2bf>    vec' </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> generation (i</span><span style=color:#adb7c9>-</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>) vec
</span><span style=color:#abb2bf>    </span><span style=color:#5cb3fa>step </span><span style=color:#cd74e8>:: Int -> Int
</span><span style=color:#abb2bf>    step i </span><span style=color:#adb7c9>= </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> (neighSum </span><span style=color:#adb7c9>> </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>then </span><span style=color:#db9d63>1 </span><span style=color:#cd74e8>else </span><span style=color:#db9d63>0
</span><span style=color:#abb2bf>      </span><span style=color:#cd74e8>where
</span><span style=color:#abb2bf>        x </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> i </span><span style=color:#db9d63>`</span><span style=color:#adb7c9>mod</span><span style=color:#db9d63>` 32
</span><span style=color:#abb2bf>        y </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> i </span><span style=color:#db9d63>`</span><span style=color:#adb7c9>div</span><span style=color:#db9d63>` 32
</span><span style=color:#abb2bf>        neighSum </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> foldr </span><span style=color:#5cb3fa>(+) </span><span style=color:#db9d63>0</span><span style=color:#abb2bf> [getCell (x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> x') (y </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> y') vec' </span><span style=color:#adb7c9>|</span><span style=color:#abb2bf> x' </span><span style=color:#adb7c9>&LT-</span><span style=color:#abb2bf> [</span><span style=color:#adb7c9>-</span><span style=color:#db9d63>1</span><span style=color:#adb7c9>..</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>], y' </span><span style=color:#adb7c9>&LT-</span><span style=color:#abb2bf> [</span><span style=color:#adb7c9>-</span><span style=color:#db9d63>1</span><span style=color:#adb7c9>..</span><span style=color:#db9d63>1</span><span style=color:#abb2bf>], not (x' </span><span style=color:#adb7c9>== </span><span style=color:#db9d63>0</span><span style=color:#abb2bf> && y' </span><span style=color:#adb7c9>== </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>) ]
</span></code></pre><p>Coupled with Haskell's <code>System.Random</code>, we get a nice looking dungeon after a few generations:<p><img alt="Cellular Automaton" src=/data/2014-10-20/ca_.png><p>You can read the whole code here: <a href=https://gist.github.com/veeenu/8dbba3e53f94d7142c63>https://gist.github.com/veeenu/8dbba3e53f94d7142c63</a>.<p>Surely this could have been done a lot better, and it will be, as I keep studying the language and getting better at it. Meanwhile, please feel free to criticize and comment whatever you feel like to! :)<p><strong>ERRATA CORRIGE</strong>. My friend Roberto pointed out that the 2-tuple <script type=math/tex>(0, 0)</script> wasn't supposed to be part of the Moore neighborhood, and, besides that, its status was already taken into account for (but not used in this particular case) in the form of <script type=math/tex>a_0</script> in the rule function anyway. This has now been corrected both in the code and in the mathematical expression.</section></article><ul class=links><li><a href=https://github.com/veeenu target=_blank> <img alt=GitHub src=/img/github.svg> </a><li><a href=https://www.linkedin.com/in/andreavenuta/ target=_blank> <img alt=LinkedIn src=/img/linkedin.svg> </a><li><a href=https://twitter.com/johndisandonato target=_blank> <img alt=Twitter src=/img/twitter.svg> </a><li><a href=https://twitch.tv/johndisandonato target=_blank> <img alt=Twitch.tv src=/img/twitch.svg> </a><li><a href=cv.pdf target=_blank> <img alt="CV - Icon made by Vitaly Gorbachev (https://www.flaticon.com/authors/vitaly-gorbachev) from www.flaticon.com" src=/img/cv.svg> </a></ul></div><script async src=/katex.min.js></script><script data-cf-beacon='{"token": "9c82a3cc7db742e4bb18aebd57b40893"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script>