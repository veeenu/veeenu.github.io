<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width" name=viewport><meta content="FEZ: engine algorithms and ideas" property=og:title><meta content=website property=og:type><meta content="Andrea Venuta" property=og:site_name><meta content="Yesterday I played for the first time Polytron&amp#x27;s FEZ.
Graphics and design are amazing, but what truly struck me was the way the game
switched between the 2D and 3D &ampquot;looks&ampquot;. It was truly inspiring, so I decided to
spend a little time understanding and recreating the world rotation engine." property=og:description><title>FEZ: engine algorithms and ideas</title><link href=https://veeenu.github.io/style.css rel=stylesheet><link href=https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet><link integrity="sha512-vJqxkZ+Sugf/6WRlpcxN01qVfX/29hF6qc33eHF1va3NgoV+U+wCi+uTAsQ10sDoGyBxHLdaHvGwDlV3yVYboA==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css referrerpolicy=no-referrer rel=stylesheet><script integrity="sha512-5ufNcHqOYgilGEHPfuRIQ5B/vDS1M8+UC+DESZ5CwVgGTg+b2Ol/15rYL/GiCWJ/Sx8oVo0FPFok1dPk8U9INQ==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js></script><script integrity="sha512-MBhOGY4yRA2eATtRGTcrDJCRqcnLai5+uu47GA2ueVr1MPzirC/iogLWRA8CXTlOTK09VI4fdTe4qE4LBfjsHw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mathtex-script-type.min.js></script><script integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js></script><script>document.addEventListener(`DOMContentLoaded`,(()=>{let a=`\$\$`,b=`\$`;renderMathInElement(document.body,{delimiters:[{left:a,right:a,display:!0},{left:b,right:b,display:!1},{left:`\\\\(`,right:`\\\\)`,display:!1},{left:`\\\\[`,right:`\\\\]`,display:!0}],throwOnError:!1})}))</script><body><header id=menu-header><a class=image href=https://veeenu.github.io> <div><img alt="Andrea Venuta" src=https://veeenu.github.io/me.jpg></div> <span>Andrea Venuta</span> </a><ul><li><a href=https://veeenu.github.io>About</a><li><a href=https://veeenu.github.io/blog.html>Blog</a></ul></header><div class="container top-container"><article class="article twelve columns"><header><h1>FEZ: engine algorithms and ideas</h1><small> <p><time>Thursday, 25 Dec 2014</time> Â· <em> Reading time: 4 mins </em></p> </small></header><section><p>Yesterday I played for the first time <a href=http://fezgame.com/>Polytron's FEZ</a>. Graphics and design are amazing, but what truly struck me was the way the game switched between the 2D and 3D "looks". It was truly inspiring, so I decided to spend a little time understanding and recreating the world rotation engine.</p><span id=continue-reading></span><p>Turns out the mind-blowing effect is simply based on orthographic view transforms. Orthographic views aren't really used in realistic optical systems, because the projection preserves proportions and line parallelism. In other words, there is no perspective and far objects look as big as near objects.<p>This means that transformations look less realistic, and also that projecting a cube directly facing the camera is exactly the same as drawing its front face, ignoring everything else, regardless of its position. Perspective projection doesn't allow that: if you draw a cube positioned in the bottom left half of the frustum and projected via a perspective matrix, you're going to see its right and top sides. What we do want here is not realism, but a way of conveniently displaying a 2D environment and occasionally rotate it about the Y axis, and orthographic projection does exactly that.<p>The idea behind it all is that the game environments are the four sides of a cube-ish structure, and switching between them causes a gradual <script type=math/tex>\frac{\pi}{2}</script> rotation of the whole environment, so that the player always faces a 2D world. The collision detection algorithms then simply ignore the dimension currently facing away from the player (e.g. in the <script type=math/tex>z</script> direction when no rotation is applied) thus making the player roam in a purely 2D environment.<h3 id=the-code>The code</h3><p>I quickly sketched these ideas and you can see the results <a href=http://bl.ocks.org/veeenu/d6ff96aae4b48e8dc26e>here</a>.</p><img alt src=/data/2014-12-25/screenshot.jpg><p>In the meantime I also did a little bit of experimenting with procedural texture generation. What I did was implement a awfully minimal voxel engine which basically took a 3D point and created and textured a cube mesh around it. After the voxels were in place, I moved on to creating an orthogonal projection matrix (whose only job was to adjust to the screen's aspect ratio) and initialized the view matrix as the identity. To simulate FEZ's rotational movement, I used a quintic easing function. To make things quick I created an easing lookup table, containing all the possible values used to animate the view matrix. The peculiarity is that I didn't map the quintic function to <script type=math/tex>\left[0, 1\right]</script> , but created a transition made of small increments. This way, instead of specifying all the possible rotation angles, I just specified how much the view matrix should rotate at every step so I don't have to reinitialize it to identity every time.<p>In the final code I restricted the rotations to the Y axis, but in the picture above you can see what the world looks like seen from an angle. A 2D view, instead, looks like this:</p><img alt src=/data/2014-12-25/screenshot2.jpg><p>I also had a little fun procedurally recreating the Minecraft's dirt block texture, inspired by <a href=http://jsfiddle.net/uzMPU/>this fiddle</a>. The idea is to have a random factor that dims the brightness a bit, and then expressing each block of the texture with its own color. The top and bottom of the texture are simply a green and brown color with noise applied. The side is green the first few pixels, brown the last few pixels, and there's a small area, around the 7th horizontal line from top, where it's left to chance whether to put a brown or a green pixel.<p>You can <a href=http://bl.ocks.org/veeenu/d6ff96aae4b48e8dc26e>see the code in action here</a>, and <a href=https://gist.github.com/veeenu/d6ff96aae4b48e8dc26e/>read it here</a>.<p>Merry Christmas! :)</section></article><ul class=links><li><a href=https://github.com/veeenu target=_blank> <img alt=GitHub src=/img/github.svg> </a><li><a href=https://www.linkedin.com/in/andreavenuta/ target=_blank> <img alt=LinkedIn src=/img/linkedin.svg> </a><li><a href=https://twitter.com/johndisandonato target=_blank> <img alt=Twitter src=/img/twitter.svg> </a><li><a href=https://twitch.tv/johndisandonato target=_blank> <img alt=Twitch.tv src=/img/twitch.svg> </a><li><a href=cv.pdf target=_blank> <img alt="CV - Icon made by Vitaly Gorbachev (https://www.flaticon.com/authors/vitaly-gorbachev) from www.flaticon.com" src=/img/cv.svg> </a></ul></div><script async src=/katex.min.js></script><script data-cf-beacon='{"token": "9c82a3cc7db742e4bb18aebd57b40893"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script>