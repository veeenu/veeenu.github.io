<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width" name=viewport><meta content="Automating the Emote Crossover industry with Rust" property=og:title><meta content=website property=og:type><meta content="Andrea Venuta" property=og:site_name><meta content="In this post, I will discuss advanced computer vision and statistical techniques
at the service of what is arguably one of the most important aspects of social
life during a global pandemic: silly emotes." property=og:description><title>Automating the Emote Crossover industry with Rust</title><link href=https://veeenu.github.io/style.css rel=stylesheet><link href=https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet><link integrity="sha512-vJqxkZ+Sugf/6WRlpcxN01qVfX/29hF6qc33eHF1va3NgoV+U+wCi+uTAsQ10sDoGyBxHLdaHvGwDlV3yVYboA==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css referrerpolicy=no-referrer rel=stylesheet><script integrity="sha512-5ufNcHqOYgilGEHPfuRIQ5B/vDS1M8+UC+DESZ5CwVgGTg+b2Ol/15rYL/GiCWJ/Sx8oVo0FPFok1dPk8U9INQ==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js></script><script integrity="sha512-MBhOGY4yRA2eATtRGTcrDJCRqcnLai5+uu47GA2ueVr1MPzirC/iogLWRA8CXTlOTK09VI4fdTe4qE4LBfjsHw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mathtex-script-type.min.js></script><script integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw==" crossorigin defer referrerpolicy=no-referrer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js></script><script>document.addEventListener(`DOMContentLoaded`,(()=>{let a=`\$\$`,b=`\$`;renderMathInElement(document.body,{delimiters:[{left:a,right:a,display:!0},{left:b,right:b,display:!1},{left:`\\\\(`,right:`\\\\)`,display:!1},{left:`\\\\[`,right:`\\\\]`,display:!0}],throwOnError:!1})}))</script><body><header id=menu-header><a class=image href=https://veeenu.github.io> <div><img alt="Andrea Venuta" src=https://veeenu.github.io/me.jpg></div> <span>Andrea Venuta</span> </a><ul><li><a href=https://veeenu.github.io>About</a><li><a href=https://veeenu.github.io/blog.html>Blog</a></ul></header><div class="container top-container"><article class="article twelve columns"><header><h1>Automating the Emote Crossover industry with Rust</h1><small> <p><time>Monday, 27 Dec 2021</time> · <em> Reading time: 16 mins </em></p> </small></header><section><p>In this post, I will discuss advanced computer vision and statistical techniques at the service of what is arguably one of the most important aspects of social life during a global pandemic: silly emotes.</p><span id=continue-reading></span><p>Who wants to constrain their communication avenues to the diktats coming from the Unicode Consortium, when you could instead enhance your vocabulary with obscure inside jokes, impenetrable to anyone outside a given narrow community? And even if you wanted that, who would waste a chance to write some Rust code? Certainly not me, dear reader.<p>(If you aren't familiar with how Twitch communities work and what Twitch emotes are, check <a href=https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/>this</a> out).<p>In the <a href=https://www.speedsouls.com/>Souls speedrunning community</a>, the hip trend in 2021 emote-based communication revolves mostly around this muscular fellow, SwoleDoge:<p><img alt=SwoleDoge src=https://cdn.frankerfacez.com/emoticon/472809/4><p>I contributed to this trend with my own creations, crossovers between the original swole doge and other emotes popular in the scene. I affectionately call them "the gang":<p><img alt=Swowee src=https://cdn.frankerfacez.com/emoticon/640489/4 style=display:inline-block> <img alt=Swomfy src=https://cdn.frankerfacez.com/emoticon/644356/4 style=display:inline-block> <img alt=SwolerZ src=https://cdn.frankerfacez.com/emoticon/673742/4 style=display:inline-block> <img alt=LilSwole src=https://cdn.frankerfacez.com/emoticon/673741/4 style=display:inline-block> <img alt=SwoleFroge src=https://cdn.frankerfacez.com/emoticon/673267/4 style=display:inline-block> <img alt=SwoleItalian src=https://cdn.frankerfacez.com/emoticon/640488/4 style=display:inline-block><p>To create them, I would match SwoleDoge's color to my target emote's color, then I would just slap the latter's face on top of it. Simple task to do in basically any sufficiently powerful image editor.<p>Now, there are two skillsets which I deem important as a software engineer: pattern matching and laziness. No, I don't mean the functional programming idioms; I mean that I noticed a pattern of myself repeating the same picture editing behavior more than twice, and I decided I was too lazy to repeat that again.<p>So, to avoid wasting <em>whole minutes</em> by manually matching two pictures' colors, I decided it was well worth embarking on <em>just a few weeks, a couple months tops</em> of research in computational image manipulation. What you are about to read is the output of that research.<p>Brew some tea, wrap yourself up in your comfy blanket and let's get started!<h2 id=color-spaces>Color spaces</h2><p>The concept of what I wanted to achieve was simple: take two images, a <em>source</em> and a <em>target</em>, and produce a version of <em>target</em> which has the color distribution of <em>source</em> (in some lax sense of color distribution). Informally, if the <em>source</em> image is mostly green and the <em>target</em> image is mostly yellow, I want a version of <em>target</em> which is mostly green, too, so that I can then paste the <em>source</em> on the <em>target</em>'s face without too much of a seam showing.<p>You may know that an image can be represented by specifying three <em>channel</em> values to mix together, and those three channels are most notoriously red, green and blue; this is the <a href=https://en.wikipedia.org/wiki/RGB_color_spaces>RGB color space</a>. There are other color spaces, though, which may be more or less intuitive to work with, and exhibit better or worse properties for achieving certain outcomes. Spoiler: RGB is not a good color space to work with for our little project, so we'll have to look elsewhere.<p><a href=https://veeenu.github.io/blog/automating-the-emote-crossover-industry-with-rust/colortransfer>This research paper</a> has some very interesting ideas. The gist of it, to be super concise, is to take each channel of our <em>target</em> image, center it around the mean of the corresponding channel in the <em>source</em> image, and scale it by the quotient of the former and latter channel's standard deviation. In RGB space, this would mean:<p>$$ R_t^* = (R_t - \mathbb{E}(R_t)) \frac{\sigma(R_s)}{\sigma(R_t)} + \mathbb{E}(R_s) $$ $$ G_t^* = (G_t - \mathbb{E}(G_t)) \frac{\sigma(G_s)}{\sigma(G_t)} + \mathbb{E}(G_s) $$ $$ B_t^* = (B_t - \mathbb{E}(B_t)) \frac{\sigma(B_s)}{\sigma(B_t)} + \mathbb{E}(B_s) $$<p>Without going into too much detail, the <a href=https://en.wikipedia.org/wiki/CIE_1931_color_space>XYZ</a> color space works pretty okay for our use case, so we don't really need to convert all the way to the <a href=https://en.wikipedia.org/wiki/LMS_color_space>LMS</a> and <a href=https://en.wikipedia.org/wiki/CIELAB_color_space>CIELAB</a> color spaces. Another crucial factor is that our emotes are not photographs. They also have markedly different color distributions, not to mention an <em>alpha</em> channel for transparency, so the original paper's approach had to be revised slightly.<h3 id=rust-implementation>Rust implementation</h3><p>Our project is made up of many array computations. Given that, we are going to use a recent nightly Rust toolchain: we need some features which still haven't made it to stable, but are pretty useful for speed and cleanliness purposes.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#abb2bf>#![</span><span style=color:#eb6772>feature</span><span style=color:#abb2bf>(array_chunks)]
</span><span style=color:#abb2bf>#![</span><span style=color:#eb6772>feature</span><span style=color:#abb2bf>(array_zip)]
</span></code></pre><p>We'll discuss them in the proper spots! For now, just trust me and<pre style=color:#6c7079;background-color:#2b303b><code><span style=color:#abb2bf>rustup default nightly
</span></code></pre><p>In most pouplar image formats, pixel values are usually stored as an array of four 8 bit integers, one per channel; hence, each channel has values ranging from 0 to 255. We want to map those to the real-valued $[0, 1]$ interval because it's more comfy to use. Here's how:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>bytes2floats</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>rgba</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>; 4]) -> [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>] {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[r, g, b, a] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> rgba;
</span><span style=color:#abb2bf>    [
</span><span style=color:#abb2bf>        r </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32 </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        g </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32 </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        b </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32 </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        a </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32 </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>    ]
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>floats2bytes</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>rgba</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; 4]) -> [</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>] {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[r, g, b, a] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> rgba;
</span><span style=color:#abb2bf>    [
</span><span style=color:#abb2bf>        (r </span><span style=color:#adb7c9>* </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        (g </span><span style=color:#adb7c9>* </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        (b </span><span style=color:#adb7c9>* </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        (a </span><span style=color:#adb7c9>* </span><span style=color:#db9d63>255.</span><span style=color:#abb2bf>) </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>    ]
</span><span style=color:#abb2bf>}
</span></code></pre><p>Most popular image formats use the RGB color space, so we want to write a couple functions to convert RGB into XYZ and vice versa. Luckily, we can achieve that via simple <a href=http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html>matrix multiplications</a>.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>rgb2xyz</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>rgb</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; 3]) -> [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>3</span><span style=color:#abb2bf>] {
</span><span style=color:#abb2bf>    #[</span><span style=color:#eb6772>rustfmt</span><span style=color:#abb2bf>::</span><span style=color:#eb6772>skip</span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> M: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>9</span><span style=color:#abb2bf>] </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[
</span><span style=color:#abb2bf>        </span><span style=color:#db9d63>0.4124564</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.3575761</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.1804375</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        </span><span style=color:#db9d63>0.2126729</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.7151522</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.0721750</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        </span><span style=color:#db9d63>0.0193339</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.1191920</span><span style=color:#abb2bf>, </span><span style=color:#db9d63>0.9503041</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>    ];
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[m11, m12, m13, m21, m22, m23, m31, m32, m33] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> M;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[r, g, b] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> rgb;
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    [
</span><span style=color:#abb2bf>        m11 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m12 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> g </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m13 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> b,
</span><span style=color:#abb2bf>        m21 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m22 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> g </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m23 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> b,
</span><span style=color:#abb2bf>        m31 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> r </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m32 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> g </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m33 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> b,
</span><span style=color:#abb2bf>    ]
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>xyz2rgb</span><span style=color:#abb2bf>(</span><span style=color:#eb6772>xyz</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; 3]) -> [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>3</span><span style=color:#abb2bf>] {
</span><span style=color:#abb2bf>    #[</span><span style=color:#eb6772>rustfmt</span><span style=color:#abb2bf>::</span><span style=color:#eb6772>skip</span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>const </span><span style=color:#db9d63>MINV</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>9</span><span style=color:#abb2bf>] </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[
</span><span style=color:#abb2bf>        </span><span style=color:#db9d63>3.2404542</span><span style=color:#abb2bf>, </span><span style=color:#adb7c9>-</span><span style=color:#db9d63>1.5371385</span><span style=color:#abb2bf>, </span><span style=color:#adb7c9>-</span><span style=color:#db9d63>0.4985314</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>       </span><span style=color:#adb7c9>-</span><span style=color:#db9d63>0.9692660</span><span style=color:#abb2bf>,  </span><span style=color:#db9d63>1.8760108</span><span style=color:#abb2bf>,  </span><span style=color:#db9d63>0.0415560</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>        </span><span style=color:#db9d63>0.0556434</span><span style=color:#abb2bf>, </span><span style=color:#adb7c9>-</span><span style=color:#db9d63>0.2040259</span><span style=color:#abb2bf>,  </span><span style=color:#db9d63>1.0572252</span><span style=color:#abb2bf>,
</span><span style=color:#abb2bf>    ];
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[m11, m12, m13, m21, m22, m23, m31, m32, m33] </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>MINV</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let </span><span style=color:#abb2bf>[x, y, z] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> xyz;
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    [
</span><span style=color:#abb2bf>        m11 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m12 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m13 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> z,
</span><span style=color:#abb2bf>        m21 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m22 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m23 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> z,
</span><span style=color:#abb2bf>        m31 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> x </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m32 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> y </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> m33 </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> z,
</span><span style=color:#abb2bf>    ]
</span><span style=color:#abb2bf>}
</span></code></pre><p>In general, we are going to try to be mindful of heap allocations in this project, and use arrays instead of <code>Vec</code>s wherever we know beforehand (i.e. at compile time) all the sizes we are supposed to work with.<p>While we're at it, let's also implement a thresholding function that will make all pixels below a certain transparency black and fully transparent. This will help with cleaning up images a bit and reducing noise. It's an assumption that we can make by virtue of what most emotes look like: a lot of transparency around the borders, a lot of color in the middle.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>threshold_alpha</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> T: </span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>>(</span><span style=color:#eb6772>rgba</span><span style=color:#abb2bf>: [</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>; 4]) -> [</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>] {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> rgba[</span><span style=color:#db9d63>3</span><span style=color:#abb2bf>] </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> T {
</span><span style=color:#abb2bf>        [</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>]
</span><span style=color:#abb2bf>    } </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>        rgba
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>}
</span></code></pre><h2 id=clustering-image-colors>Clustering image colors</h2><p>The attentive reader may have noticed that in most images the body is made up of more than one dominant color; the froge, for example, has two shades of green, and <a href=https://knowyourmeme.com/memes/frankerz>FrankerZ</a> has a part white, part brown head.<p>The intuitive concept of "FrankerZ is made of a white part and a brown part" can be modeled with the statistical technique of <a href=https://en.wikipedia.org/wiki/Cluster_analysis>clustering</a>. Clustering algorithms take points in an $N$-dimensional vector space and arrange them in $K$ groups according to a given measure of similarity. In a color space, points that are <a href=https://en.wikipedia.org/wiki/Euclidean_distance>close together</a> translate to colors that are similar to each other, so clustering pixels of an image according to their closeness means that we can build $K$ groups of pixels of similar colors.<p>A very popular clustering algorithm is <a href=https://en.wikipedia.org/wiki/K-means_clustering>K-means</a>. It is an iterative algorithm that partitions our data points in $K$ groups, and at each iteration the variance in each group decreases towards a local minimum. We start with an initial estimation of $K$ <em>centroids</em>, one per group. At each step, we first assign each point to the group of its closest centroid, and then we update the group's centroid to be the <em>mean</em> of the points currently belonging to it.<h3 id=rust-implementation-1>Rust implementation</h3><p>The algorithm in Rust looks elegant and concise, and it is also reasonably fast, if I say so myself! Again, we leverage all the compile time computation we can: we use <a href=https://rust-lang.github.io/rfcs/2000-const-generics.html>const generics</a> so we can implement the algorithm for arbitrary-sized vector spaces and arbitrary number of partitions $K$ with constants instead of variables. This makes the optimizer pretty happy because it can make all sorts of assumptions.<p>We also use the <code>array_zip</code> unstable feature in some places. This allows us to avoid the <code>.iter()</code> notation in some awkward spots and supposedly also makes the optimizer all warm and fuzzy -- and I mean, I'm happy too if I can just cough up some unrolled assembly loops while using high level functional constructs.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>struct </span><span style=color:#abb2bf>KMeans<</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> K: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>> {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#eb6772>means</span><span style=color:#abb2bf>: [[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K],
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#eb6772>labels</span><span style=color:#abb2bf>: Vec<</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>,
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>distance</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D], </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]) -> </span><span style=color:#cd74e8>f32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    a.</span><span style=color:#5ebfcc>zip</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>b).</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>)| (a </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> b).</span><span style=color:#5ebfcc>powf</span><span style=color:#abb2bf>(</span><span style=color:#db9d63>2.</span><span style=color:#abb2bf>)).</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().sum::<</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>>()
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>k_means</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> K: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> ITERS: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>(
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>points</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]],
</span><span style=color:#abb2bf>) -> KMeans&LTK, D> {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> centroids </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>k_means_init</span><span style=color:#abb2bf>(points);
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> labels </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>Vec::with_capacity(points.</span><span style=color:#5ebfcc>len</span><span style=color:#abb2bf>());
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#adb7c9>_ in </span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..</span><span style=color:#db9d63>ITERS </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> labels_hist </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>; K];
</span><span style=color:#abb2bf>        labels.</span><span style=color:#5ebfcc>clear</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>        labels.</span><span style=color:#5ebfcc>extend</span><span style=color:#abb2bf>(points.</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>p</span><span style=color:#abb2bf>| {
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> label </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> centroids
</span><span style=color:#abb2bf>                .</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>                .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>c</span><span style=color:#abb2bf>| </span><span style=color:#5ebfcc>distance</span><span style=color:#abb2bf>(c, p))
</span><span style=color:#abb2bf>                .</span><span style=color:#5ebfcc>enumerate</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>                .</span><span style=color:#5ebfcc>fold</span><span style=color:#abb2bf>((</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>::</span><span style=color:#db9d63>MAX</span><span style=color:#abb2bf>), |(</span><span style=color:#eb6772>label</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>distance</span><span style=color:#abb2bf>), (</span><span style=color:#eb6772>l</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>d</span><span style=color:#abb2bf>)| {
</span><span style=color:#abb2bf>                    </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> d </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> distance {
</span><span style=color:#abb2bf>                        (l, d)
</span><span style=color:#abb2bf>                    } </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>                        (label, distance)
</span><span style=color:#abb2bf>                    }
</span><span style=color:#abb2bf>                })
</span><span style=color:#abb2bf>                .</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>            labels_hist[label] </span><span style=color:#adb7c9>+= </span><span style=color:#db9d63>1</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>            label
</span><span style=color:#abb2bf>        }));
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> labels_weights: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; K] </span><span style=color:#adb7c9>=
</span><span style=color:#abb2bf>            labels_hist.</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>h</span><span style=color:#abb2bf>| </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> h </span><span style=color:#adb7c9>== </span><span style=color:#db9d63>0 </span><span style=color:#abb2bf>{ </span><span style=color:#db9d63>0. </span><span style=color:#abb2bf>} </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{ </span><span style=color:#db9d63>1. </span><span style=color:#adb7c9>/ </span><span style=color:#abb2bf>(h </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>) });
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        centroids </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[[</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K];
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>        labels.</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>enumerate</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>for_each</span><span style=color:#abb2bf>(|(</span><span style=color:#eb6772>i</span><span style=color:#abb2bf>, &</span><span style=color:#eb6772>l</span><span style=color:#abb2bf>)| {
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> d </span><span style=color:#adb7c9>in </span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..</span><span style=color:#abb2bf>D {
</span><span style=color:#abb2bf>                centroids[l][d] </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> points[i][d] </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> labels_weights[l];
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        });
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    KMeans {
</span><span style=color:#abb2bf>        means: centroids,
</span><span style=color:#abb2bf>        labels,
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>}
</span></code></pre><p>Let's go over this code step by step. First of all, we define a data structure that will be the output of our computation. For finding $K$ means in a $D$-dimensional space, the function will return an instance of <code>KMeans&LTK, D></code>. For example, if we want 4 clusters of 3-dimensional RGB colors, we will have a <code>KMeans&LT4, 3></code>. We also want to return the label of each pixel, i.e. the index of the mean of the cluster it belongs to. We will store that in the <code>labels</code> vector; yes, we will reluctantly have to resort to the heap for this.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>struct </span><span style=color:#abb2bf>KMeans<</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> K: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>> {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#eb6772>means</span><span style=color:#abb2bf>: [[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K],
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#eb6772>labels</span><span style=color:#abb2bf>: Vec<</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>,
</span><span style=color:#abb2bf>}
</span></code></pre><p>We also need a simple Euclidean distance function:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>distance</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D], </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]) -> </span><span style=color:#cd74e8>f32 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>    a.</span><span style=color:#5ebfcc>zip</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>b).</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|(</span><span style=color:#eb6772>a</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>b</span><span style=color:#abb2bf>)| (a </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> b).</span><span style=color:#5ebfcc>powf</span><span style=color:#abb2bf>(</span><span style=color:#db9d63>2.</span><span style=color:#abb2bf>)).</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().sum::<</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>>()
</span><span style=color:#abb2bf>}
</span></code></pre><p>Our $K$-means function accepts an array of points of given dimensionality D, and returns an instance of <code>KMeans&LTK, D></code>. We preallocate the vector space we know we need (we can't use an array, as we don't know how much space we need at compile time) and initialize the centroids (more on this later). We also specify a const generic for the number of iterations.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>pub</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>crate</span><span style=color:#abb2bf>) </span><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>k_means</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> K: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> ITERS: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>(
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>points</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]],
</span><span style=color:#abb2bf>) -> KMeans&LTK, D> {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> centroids </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>k_means_init</span><span style=color:#abb2bf>(points);
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> labels </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>Vec::with_capacity(points.</span><span style=color:#5ebfcc>len</span><span style=color:#abb2bf>());
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#adb7c9>_ in </span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..</span><span style=color:#db9d63>ITERS </span><span style=color:#abb2bf>{
</span></code></pre><p>The iteration step works by writing into the preallocated <code>labels</code> vector the label of the closest current centroid for each pixel. This evaluation happens inside the call to <code>fold()</code>, where each centroid is compared with the pixel we are currently iterating over, and the centroid with the smaller distance is passed through. We also keep tabs on how many instances of each label we have found, by incrementing the <code>labels_hist</code> array's entry corresponding to the label we just found.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> labels_hist </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>; K];
</span><span style=color:#abb2bf>labels.</span><span style=color:#5ebfcc>clear</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>labels.</span><span style=color:#5ebfcc>extend</span><span style=color:#abb2bf>(points.</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>p</span><span style=color:#abb2bf>| {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> label </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> centroids
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>c</span><span style=color:#abb2bf>| </span><span style=color:#5ebfcc>distance</span><span style=color:#abb2bf>(c, p))
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>enumerate</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>fold</span><span style=color:#abb2bf>((</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>::</span><span style=color:#db9d63>MAX</span><span style=color:#abb2bf>), |(</span><span style=color:#eb6772>label</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>distance</span><span style=color:#abb2bf>), (</span><span style=color:#eb6772>l</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>d</span><span style=color:#abb2bf>)| {
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> d </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> distance {
</span><span style=color:#abb2bf>                (l, d)
</span><span style=color:#abb2bf>            } </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>                (label, distance)
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>        })
</span><span style=color:#abb2bf>        .</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    labels_hist[label] </span><span style=color:#adb7c9>+= </span><span style=color:#db9d63>1</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    label
</span><span style=color:#abb2bf>}));
</span></code></pre><p>Now we need to compute the new centroids. Recall that the mean is computed as<p>$$ \mathbb{E}(x) = \sum_{i=1}^{N} \frac{x_i}{N} $$<p>For each cluster, our $K$ is the number of points in the cluster. We stored that value in the histogram array <code>label_hist</code>, so we can simply take that value for each of the $K$ clusters and compute its inverse.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> labels_weights: [</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; K] </span><span style=color:#adb7c9>=
</span><span style=color:#abb2bf>    labels_hist.</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|</span><span style=color:#eb6772>h</span><span style=color:#abb2bf>| </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> h </span><span style=color:#adb7c9>== </span><span style=color:#db9d63>0 </span><span style=color:#abb2bf>{ </span><span style=color:#db9d63>0. </span><span style=color:#abb2bf>} </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{ </span><span style=color:#db9d63>1. </span><span style=color:#adb7c9>/ </span><span style=color:#abb2bf>(h </span><span style=color:#adb7c9>as </span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>) });
</span></code></pre><p>Finally, we reinitialize the centroids to zero, and compute the above weighted summation:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#abb2bf>centroids </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[[</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K];
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>labels.</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>enumerate</span><span style=color:#abb2bf>().</span><span style=color:#5ebfcc>for_each</span><span style=color:#abb2bf>(|(</span><span style=color:#eb6772>i</span><span style=color:#abb2bf>, &</span><span style=color:#eb6772>l</span><span style=color:#abb2bf>)| {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> d </span><span style=color:#adb7c9>in </span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..</span><span style=color:#abb2bf>D {
</span><span style=color:#abb2bf>        centroids[l][d] </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> points[i][d] </span><span style=color:#adb7c9>*</span><span style=color:#abb2bf> labels_weights[l];
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>});
</span></code></pre><h4 id=initialization>Initialization</h4><p>The output of $K$-means largely depends on the choice of starting centroids. The naïve way of doing that is just choosing random points in our vector space, or sampling random points from our observations (i.e. taking one of the actual pixels at random). These initialization methods are suboptimal, though, and tend to be inconsistent. We can rely on the <a href=https://en.wikipedia.org/wiki/K-means%2B%2B>K-means++</a> algorithm for a reliable initial guess. It works by choosing a (possibly random) pixel value as our first centroid and then, for each of the other $1..K$ centroids, choosing the pixel which has the maximum distance from its closest centroid. It's kind of a mouthful, I know.<p>In our implementation, we take the center pixel as first centroid, because we assume it's going to have a color we're interested in, and then we go from there.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>fn </span><span style=color:#5cb3fa>k_means_init</span><span style=color:#abb2bf><</span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> K: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>, </span><span style=color:#cd74e8>const</span><span style=color:#abb2bf> D: </span><span style=color:#cd74e8>usize</span><span style=color:#abb2bf>>(
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>points</span><span style=color:#abb2bf>: </span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>[[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]]
</span><span style=color:#abb2bf>) -> [[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K] {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let mut</span><span style=color:#abb2bf> centroids </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>[[</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D]; K];
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    centroids[</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> points[points.</span><span style=color:#5ebfcc>len</span><span style=color:#abb2bf>() </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>2</span><span style=color:#abb2bf>];
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>in </span><span style=color:#db9d63>1</span><span style=color:#adb7c9>..</span><span style=color:#abb2bf>K {
</span><span style=color:#abb2bf>        centroids[i] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> points
</span><span style=color:#abb2bf>            .</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>            .</span><span style=color:#5ebfcc>fold</span><span style=color:#abb2bf>(([</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D], </span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>), |</span><span style=color:#eb6772>farthest</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>cur</span><span style=color:#abb2bf>| {
</span><span style=color:#abb2bf>                </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> closest_centroid </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> centroids[</span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..</span><span style=color:#abb2bf>i]
</span><span style=color:#abb2bf>                    .</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>                    .</span><span style=color:#5ebfcc>fold</span><span style=color:#abb2bf>(([</span><span style=color:#db9d63>0</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; D], </span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>::</span><span style=color:#db9d63>MAX</span><span style=color:#abb2bf>), |</span><span style=color:#eb6772>closest</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>centroid</span><span style=color:#abb2bf>| {
</span><span style=color:#abb2bf>                        </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dist </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>distance</span><span style=color:#abb2bf>(cur, centroid);
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>                        </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> closest.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> dist {
</span><span style=color:#abb2bf>                            closest
</span><span style=color:#abb2bf>                        } </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>                            (</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>centroid, dist)
</span><span style=color:#abb2bf>                        }
</span><span style=color:#abb2bf>                    })
</span><span style=color:#abb2bf>                    .</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>                </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dist </span><span style=color:#adb7c9>= </span><span style=color:#5ebfcc>distance</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>closest_centroid, cur);
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>                </span><span style=color:#cd74e8>if</span><span style=color:#abb2bf> farthest.</span><span style=color:#db9d63>1 </span><span style=color:#adb7c9>></span><span style=color:#abb2bf> dist {
</span><span style=color:#abb2bf>                    farthest
</span><span style=color:#abb2bf>                } </span><span style=color:#cd74e8>else </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>                    (</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>cur, dist)
</span><span style=color:#abb2bf>                }
</span><span style=color:#abb2bf>            })
</span><span style=color:#abb2bf>            .</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>
</span><span style=color:#abb2bf>    centroids.</span><span style=color:#5ebfcc>reverse</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>    centroids
</span><span style=color:#abb2bf>}
</span></code></pre><h4 id=the-results>The results</h4><p>Here's what all the above shenanigans look like on FrankerZ and ConcernFroge, with $K = 3$.<p style=text-align:center><img id=src1 src=frankerz.png style=width:64px;display:inline-block> <span id=dst1 style=display:inline-block></span><p style=text-align:center><img id=src2 src=concernfroge.png style=width:64px;display:inline-block> <span id=dst2 style=display:inline-block></span></p><script>(()=>{let a=()=>{if(!!window.find_k_means){window.find_k_means(document.querySelector(`#src1`),document.querySelector(`#dst1`));window.find_k_means(document.querySelector(`#src2`),document.querySelector(`#dst2`))}else{requestAnimationFrame(a)}};a()})()</script><h2 id=color-transfer>Color transfer</h2><p>Let us now implement the modified <a href=https://www.cs.tau.ac.il/~turkel/imagepapers/ColorTransfer.pdf>color transfer</a> algorithm we mentioned before. We assume that our inputs are flat vectors of 8-bit RGBA pixels, one for our source and one for our target (or destination) image:<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> src_data: Vec<</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>> </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>vec![r, g, b, a, r, g, b, a, </span><span style=color:#adb7c9>...</span><span style=color:#abb2bf>];
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dst_data: Vec<</span><span style=color:#cd74e8>u8</span><span style=color:#abb2bf>> </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>vec![r, g, b, a, r, g, b, a, </span><span style=color:#adb7c9>...</span><span style=color:#abb2bf>];
</span></code></pre><p>We reshape those into vectors of four single-precision floats, thanks to the magic of <code>array_chunks()</code>, which is the other unstable feature we opted into. This allows us to have vectors of arrays of a known size. Guess who's going to be happy about that? Yeah, exactly, our good friend the optimizer! But also us, because we won't have to sort-of manually do unnecessary bounds checking and weird iterations, and we can just destructure arrays in the code instead, which looks a lot cleaner. We can't do everything at compile time and on the stack, though, so we're going to cave in and allocate a little bit of memory on the heap.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> src_data_xyza: Vec<[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>]> </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> src_data
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>data</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>as_slice</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .array_chunks::&LT4>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>copied</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(threshold_alpha::&LT200>)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(bytes2floats)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(rgba2xyza)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>collect</span><span style=color:#abb2bf>();
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dst_data_xyza: Vec<[</span><span style=color:#cd74e8>f32</span><span style=color:#abb2bf>; </span><span style=color:#db9d63>4</span><span style=color:#abb2bf>]> </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> dst_data
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>data</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>as_slice</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .array_chunks::&LT4>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>copied</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(threshold_alpha::&LT200>)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(bytes2floats)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(rgba2xyza)
</span><span style=color:#abb2bf>    .</span><span style=color:#5ebfcc>collect</span><span style=color:#abb2bf>();
</span></code></pre><p>All that's left for us to do is to compute our $K$ means for our source image and apply the transformation to the target image. We subtract the target mean and add back the source mean to each channel except the alpha -- we're okay with it just being unchanged, as we've already cleaned it via the thresholding function.<pre class=language-rust data-lang=rust style=color:#6c7079;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#cd74e8>let</span><span style=color:#abb2bf> src_means </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>k_means::&LT3, 4, 10>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>src_data_xyza);
</span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dst_means </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>k_means::&LT2, 4, 10>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>dst_data_xyza);
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> src_mean </span><span style=color:#adb7c9>in</span><span style=color:#abb2bf> src_means.means {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> output </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> dst_data_xyza
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>iter</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>copied</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>enumerate</span><span style=color:#abb2bf>()
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(|(</span><span style=color:#eb6772>idx</span><span style=color:#abb2bf>, </span><span style=color:#eb6772>mut dst_color</span><span style=color:#abb2bf>)| {
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> label </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> dst_means.labels[idx];
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>let</span><span style=color:#abb2bf> dst_mean </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> dst_means.means[label];
</span><span style=color:#abb2bf>            </span><span style=color:#cd74e8>for</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>in </span><span style=color:#db9d63>0</span><span style=color:#adb7c9>..=</span><span style=color:#db9d63>2 </span><span style=color:#abb2bf>{
</span><span style=color:#abb2bf>                dst_color[i] </span><span style=color:#adb7c9>=</span><span style=color:#abb2bf> dst_color[i] </span><span style=color:#adb7c9>-</span><span style=color:#abb2bf> dst_mean[i] </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> src_mean[i];
</span><span style=color:#abb2bf>            }
</span><span style=color:#abb2bf>            dst_color
</span><span style=color:#abb2bf>        })
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>map</span><span style=color:#abb2bf>(xyza2rgba)
</span><span style=color:#abb2bf>        .</span><span style=color:#5ebfcc>flat_map</span><span style=color:#abb2bf>(floats2bytes)
</span><span style=color:#abb2bf>        .collect::&LTVec<</span><span style=color:#adb7c9>_</span><span style=color:#abb2bf>>>();
</span><span style=color:#abb2bf>}
</span></code></pre><p>You may have noticed we also clustered the target image in two partitions. This is because, as I mentioned earlier, emotes generally have a lot of transparency around the edges and a lot of color in the center, and averaging all of it is going to look bad (the transparent color actually counts as black, mostly). We apply the transformation to each destination pixel against the mean of its own cluster; ideally, the more destination clusters, the more refined will be the resulting transformation, up to a point where the clusters will be too similar to each other and we start getting weird results. Two destination clusters work just fine for target images without a lot of color variations, like our SwoleDoge.<p>With that <code>for</code> loop, we output a modified image for each source centroid, so we can just overlay them into shape later. You'll notice that one of the output images is useless and mostly black -- that's because its source cluster is made of black transparent pixels.<h2 id=the-final-result>The final result</h2><p>Okay! It is now time to put everything together. These two are, respectively, our source and target emotes:<p style=text-align:center><img id=src src=frankerz.png style=display:inline-block> <img id=dst src=SwoleDoge.png style=display:inline-block><p>Let's mash them up! Here's the result:<div id=result style=text-align:center></div><script>(()=>{let g=`dragover`,i=`drop`,h=`copy`,f=`load`;var a=((a,b)=>{const c=new FileReader();c.addEventListener(f,a=>{b.src=a.target.result;b.addEventListener(f,e)});c.readAsDataURL(a.dataTransfer.files[0])});const b=document.querySelector(`#src`);const c=document.querySelector(`#dst`);const d=document.querySelector(`#result`);b.addEventListener(g,a=>{a.stopPropagation();a.preventDefault();a.dataTransfer.dropEffect=h});b.addEventListener(i,c=>{c.stopPropagation();c.preventDefault();a(c,b)});c.addEventListener(g,a=>{a.stopPropagation();a.preventDefault();a.dataTransfer.dropEffect=h});c.addEventListener(i,b=>{b.stopPropagation();b.preventDefault();a(b,c)});let e=()=>{if(!!window.transfer_colors){console.log(`transfer colors`);d.innerHTML=``;window.transfer_colors(b,c,d)}else{requestAnimationFrame(e)}};e()})()</script><p>Impressive, right? Granted, we haven't mounted any head on top of any other head, but that's an entirely different matter and probably another couple months' worth of research, so I think I'll let that go for the time being.<p><em>"Yeah but, like, dude, <strong>why</strong> is it always Rust"</em><p>Well, yeah, you're right, I could've just whipped up a <a href=https://jupyter.org/>Jupyter</a> notebook, <a href=https://scipy.org/>scipy</a>, <a href=https://numpy.org/>numpy</a> and <a href=https://pillow.readthedocs.io/en/stable/>Pillow</a> and been done with it for a while already. And I did that indeed for prototyping all of this and it was fantastic in its own way. But. I chose Rust because after spending almost my entire career dissatisfied with programming languages and their ecosystems, I have finally found one that genuinely makes me happy and cares deeply about all the things I care deeply about -- cleanliness, correctness, performance, maintainability, you name it -- for things I'm meant to run in production.<p>And oh.<p>There's something else, I almost forgot.<p>You can run very complex stuff on the web in the blink of an eye with it.<p>Don't believe me? Okay then, try this. Take an emote from somewhere, download it, then come back here and scroll up a bit. Take the emote you just downloaded and drag it over either FrankerZ or SwoleDoge. Go ahead. I'll wait!<h2 id=conclusions>Conclusions</h2><p>Thank you for the time you chose to spend reading this. I'm glad you did and I hope you enjoyed it!<p>A special thank you to Spacey, whose help in editing this post was invaluable.<p>If you want to check out the project's code, you can find it on <a href=https://github.com/veeenu/protein-wasm>my github</a>. If you have questions or want to chat, feel free to DM or mention me on <a href=https://twitter.com/johndisandonato>Twitter</a>!<p>Till next time. Take care!</p><script defer src=bootstrap.js></script></section></article><ul class=links><li><a href=https://github.com/veeenu target=_blank> <img alt=GitHub src=/img/github.svg> </a><li><a href=https://www.linkedin.com/in/andreavenuta/ target=_blank> <img alt=LinkedIn src=/img/linkedin.svg> </a><li><a href=https://twitter.com/johndisandonato target=_blank> <img alt=Twitter src=/img/twitter.svg> </a><li><a href=https://twitch.tv/johndisandonato target=_blank> <img alt=Twitch.tv src=/img/twitch.svg> </a><li><a href=cv.pdf target=_blank> <img alt="CV - Icon made by Vitaly Gorbachev (https://www.flaticon.com/authors/vitaly-gorbachev) from www.flaticon.com" src=/img/cv.svg> </a></ul></div><script async src=/katex.min.js></script><script data-cf-beacon='{"token": "9c82a3cc7db742e4bb18aebd57b40893"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script>